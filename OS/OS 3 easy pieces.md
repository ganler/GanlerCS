# OS 3 easy pieces

[TOC]

![](book.jpg)

## Visualization

### Process

#### åˆ†ç¦»ç­–ç•¥å’Œæœºåˆ¶

å³å°†**é«˜å±‚ç­–ç•¥**ä¸**åº•å±‚å®ç°**åˆ†å¼€è®¾è®¡ã€‚

#### è¿›ç¨‹åˆ›å»º

- åŠ è½½æ‰€æœ‰å¯¹åº”çš„ä»£ç å’Œé™æ€æ•°æ®åˆ°è¿›ç¨‹å¯¹åº”çš„åœ°å€ç©ºé—´ä¸­ã€‚ï¼ˆlazilyæ‰§è¡Œï¼‰
- åˆ›å»ºè¿è¡Œæ—¶æ ˆï¼Œä¸ºè¿è¡Œæ—¶æ ˆåˆ†é…å†…å­˜
- å¿…è¦çš„è¯ï¼Œåˆ†é…ä¸€å®šçš„å †å†…å­˜
- å…¶ä»–åˆå§‹åŒ–ä»»åŠ¡ï¼ˆå¦‚I/Oï¼‰

#### è¿›ç¨‹çŠ¶æ€

- è¿è¡Œ
- å µå¡
- å°±ç»ª

#### PCB

> ä»¥xv6ä¸ºä¾‹

- ä¸Šä¸‹æ–‡`context`ï¼ˆå„ç§å¯„å­˜å™¨ï¼‰
- è¿›ç¨‹åœ°å€ç©ºé—´ï¼ˆåˆå§‹ä½ç½®ä¸å¤§å°ï¼‰
- å†…æ ¸æ ˆçš„æ ˆåº•åœ°å€
- è¿›ç¨‹çŠ¶æ€
- pid
- çˆ¶è¿›ç¨‹
- chan, killed
- Open file
- å½“å‰è·¯å¾„
- Trap frame

> é™¤äº†ä¸‰å¤§çŠ¶æ€ï¼ˆä¸‰å¤§çŠ¶æ€çš„ç‰¹ç‚¹æ˜¯ä¼šå¤šæ¬¡å‡ºç°ï¼‰è¿˜æœ‰**åˆå§‹çŠ¶æ€**ï¼ˆæ­£åœ¨å»ºç«‹ï¼‰ï¼Œ**åƒµå°¸çŠ¶æ€**ï¼ˆè¿›ç¨‹é€€å‡ºä½†æœªæ¸…ç†ï¼‰ã€‚

#### API

- `fork`ï¼šåˆ›å»ºå­è¿›ç¨‹ï¼Œæ‰§è¡Œå½“å‰çˆ¶è¿›ç¨‹forkåçš„ä»£ç ã€‚

> å­è¿›ç¨‹å¹¶ä¸æ˜¯å®Œæ•´çš„æ‹·è´çˆ¶è¿›ç¨‹ï¼Œå…¶ä»forkè¿”å›çš„å€¼æ˜¯ä¸åŒçš„ã€‚

```c++
#include <cstdio>
#include <unistd.h>

// rc == 0 => å½“å‰è¿›ç¨‹å°±æ˜¯å­è¿›ç¨‹
// rc <  0 => å¤±è´¥

int main()
{
    printf("Now --> pid:%d\n", (int)getpid());
    int rc = fork();
    if( rc < 0 ) // fork failed
        printf("fork failed\n");
    else if( rc == 0 ) // child process
        printf("--> Child: %d\n", (int) getpid());
    else
        printf("--> Father( %d ) of %d\n", (int) getpid(), rc);
}
```

- `wait`

```c++
#include <cstdio>
#include <unistd.h>
#include <sys/wait.h>

// rc == 0 => å½“å‰è¿›ç¨‹å°±æ˜¯å­è¿›ç¨‹
// rc <  0 => å¤±è´¥

int main()
{
    printf("Now --> pid:%d\n", (int)getpid());
    int rc = fork();
    if( rc < 0 ) // fork failed
        printf("fork failed\n");
    else if( rc == 0 ) // child process
        printf("--> Child: %d\n", (int) getpid());
    else
    {
        int wc = wait(NULL); // ç­‰å¾…å­è¿›ç¨‹æ‰§è¡Œå®Œæ¯•ã€‚
        printf("--> Father( %d ) of %d\n", (int) getpid(), rc);
    }
}
```

- `exec`

> forkåï¼Œå¯è°ƒç”¨execå»æ‰§è¡Œåˆ«çš„ç¨‹åºã€‚è¿™æ ·ä¸ä¼šäº§ç”Ÿæ–°çš„å­è¿›ç¨‹ã€‚
>
> è°ƒç”¨execåï¼Œå½“å‰å­è¿›ç¨‹çš„ç¨‹åºï¼Œé™æ€æ•°æ®ï¼Œå †ï¼Œæ ˆç­‰éƒ½ä¼šè¢«è¦†ç›–ï¼ˆé‡æ–°åˆå§‹åŒ–ï¼‰ï¼Œç„¶åæ‰§è¡Œexecå¯¹åº”çš„ç¨‹åºã€‚ï¼ˆä½¿ç”¨execä¹‹åï¼Œexecä¹‹åçš„ç¨‹åºéƒ½æ²¡äº†ï¼Œå› ä¸ºå½“å‰è¿›ç¨‹è¢«åˆ·æ–°äº†ï¼Œå…¶ä¹Ÿä¼šæœ‰è¿”å›å€¼ï¼Œä½†æ˜¯æˆåŠŸè°ƒç”¨çš„è¯ä¸ä¼šè¿”å›ï¼‰
>
> <u>å¯¹execçš„æˆåŠŸè°ƒç”¨æ°¸è¿œéƒ½ä¸ä¼šè¿”å›ã€‚</u>

```c++
#include <unistd.h>
#include <cstdio>
#include <sys/wait.h>

int main()
{
    auto fuck = fork();
    char* f[] =  {"echo", "balabala", nullptr};
    if(fuck == 0)
        execvp(f[0], f);
    else
        wait(NULL);
    printf("hello\n"); // å¹¶ä¸ä¼šè¾“å‡º2æ¬¡
}
```

```c++
#include <unistd.h>
#include <cstdio>
#include <sys/wait.h>

int main()
{
    auto fuck = fork();
    char* f[] =  {"echo1", "balabala", nullptr}; // é”™è¯¯
    if(fuck == 0)
        execvp(f[0], f);
    else
        wait(NULL);
    printf("hello\n"); // è¾“å‡º2æ¬¡
}
```

```c++
#include <cstdio>
#include <unistd.h>
#include <sys/wait.h>
#include <cstring>

// rc == 0 => å½“å‰è¿›ç¨‹å°±æ˜¯å­è¿›ç¨‹
// rc <  0 => å¤±è´¥

int main()
{
    printf("Now --> pid:%d\n", (int)getpid());
    int rc = fork();
    if( rc < 0 ) // fork failed
        printf("fork failed\n");
    else if( rc == 0 ) // child process
    {
        printf("--> Child: %d\n", (int) getpid());
        char* args[3] = {
                strdup("wc"),
                strdup("../util.hpp"),
                nullptr
        };
        execvp(args[0], args);
        printf("child is doing sth\n");
    }
    else
    {
        int wc = wait(NULL); // ç­‰å¾…å­è¿›ç¨‹æ‰§è¡Œå®Œæ¯•ã€‚
        printf("--> Father( %d ) of %d\n", (int) getpid(), rc);
    }
}
```

#### Shell

- shellä¹Ÿæ˜¯ä¸€ä¸ªç¨‹åºï¼Œæˆ‘ä»¬é€šè¿‡ä¼ å…¥shellå‘½ä»¤ï¼Œshellæ”¶åˆ°å‘½ä»¤åforkå†execï¼ˆçš„æŸä¸ªå˜ä½“ï¼‰ï¼Œå†è°ƒç”¨waitç­‰å¾…è¿›ç¨‹ç»“æŸã€‚
- **é‡å®šå‘çš„å®ç°**ï¼šè°ƒç”¨execå‰å…³é—­stdioï¼Œæ‰“å¼€ç›®æ ‡æ–‡ä»¶ï¼Œç„¶åè¾“å‡ºåˆ°è¯¥æ–‡ä»¶ä¸Šã€‚

```c++
#include <fcntl.h>

// ...

close(STDOUT_FILENO);
open(output_file, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);

// ...
```

- UNIXç®¡é“ï¼Œä½¿ç”¨äº†pipe()ç³»ç»Ÿè°ƒç”¨ã€‚ä¸€ä¸ª**è¿›ç¨‹çš„è¾“å‡º**è¢«é“¾æ¥åˆ°äº†ä¸€ä¸ªå†…æ ¸ç®¡é“ä¸Šï¼ˆé˜Ÿåˆ—ï¼‰ï¼Œå¦å¤–ä¸€ä¸ª**è¿›ç¨‹çš„è¾“å…¥**ä¹Ÿè¢«é“¾æ¥åˆ°äº†ä¸€ä¸ªå†…æ ¸ç®¡é“ä¸Šã€‚ç„¶åç›¸äº’matchï¼Œä»¥å®ç°ç®¡é“ã€‚`grep -r main ./* | wc -l`ã€‚

#### å—é™ç›´æ¥æ‰§è¡Œ

è™šæ‹ŸåŒ–æœºåˆ¶çš„2å¤§é‡ç‚¹ï¼š

- æ§åˆ¶æƒï¼ˆä¿è¯æ“ä½œç³»ç»Ÿè‡ªç”Ÿçš„æ§åˆ¶æƒï¼‰
- é«˜æ€§èƒ½ï¼ˆå°½é‡æ¥è¿‘zero-overheadï¼‰

> ç›´æ¥è¿è¡Œåè®®ï¼ˆæ— é™åˆ¶ï¼‰

|                              OS                              |          Program          |
| :----------------------------------------------------------: | :-----------------------: |
| åœ¨è¿›ç¨‹åˆ—è¡¨ä¸Šåˆ›å»ºæ¡ç›®<br />ä¸ºç¨‹åºåˆ†é…å†…å­˜<br />åŠ è½½ç¨‹åºå’Œé™æ€æ•°æ®<br />æ ¹æ®argc/argvè®¾ç½®è¿è¡Œæ—¶æ ˆ<br />æ¸…ç©ºå¯„å­˜å™¨<br />call main |                           |
|                                                              | æ‰§è¡Œmain<br />return main |
|               é‡Šæ”¾è¿›ç¨‹å†…å­˜ï¼Œå¹¶ä»è¿›ç¨‹åˆ—è¡¨ä¸­ç§»é™¤               |                           |

> ç›´æ¥è¿è¡Œçš„ä¼˜ç‚¹æ˜¯å¿«é€Ÿï¼Œä½†è¿™æ ·æ— æ³•è¿›è¡Œå—é™æ“ä½œï¼ˆå› ä¸ºæ“ä½œç³»ç»Ÿä»£ç æ— æ³•æ§åˆ¶ï¼‰ã€‚

> **å—é™æ“ä½œ**ï¼š
>
> åŒºåˆ†ç”¨æˆ·æ¨¡å¼å’Œå†…æ ¸æ¨¡å¼ï¼šç”¨æˆ·æ¨¡å¼ä¸èƒ½å®Œå…¨è®¿é—®èµ„æºï¼Œè€Œå†…æ ¸æ¨¡å¼å¯ã€‚å†…æ ¸é€šè¿‡â€œç³»ç»Ÿè°ƒç”¨â€å‘ç”¨æˆ·ä»£ç æä¾›ä¸€äº›ç‰¹æ®Šçš„å—é™åŠŸèƒ½ã€‚
>
> > è¦æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œç¨‹åºå¿…é¡»æ‰§è¡Œç‰¹æ®Šçš„**<u>é™·é˜±æŒ‡ä»¤</u>**ã€‚
> >
> > - è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ -> **é™·å…¥å†…æ ¸(trap)**
> > - å°†ç‰¹æƒçº§åˆ«æå‡ä¸ºå†…æ ¸æ¨¡å¼
> > - è¿”å› -> **é™·é˜±è¿”å›(return-from-trap)**
> > - é™ä½ç‰¹æƒçº§åˆ«
>
> > x86æ¶æ„åœ¨è¿›è¡Œç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™ä¼šæŠŠå¯„å­˜å™¨pushåˆ°**å†…æ ¸æ ˆ**ä¸Šï¼Œè¿”å›æ—¶å†popã€‚
>
> > trapåï¼Œæ“ä½œç³»ç»Ÿæ ¹æ®ä¸åŒçš„å¼‚å¸¸ç ï¼Œæ‰¾åˆ°å¯¹åº”çš„å†…æ ¸ä»£ç å¹¶æ‰§è¡Œã€‚è¿™ä¸ªæ‰¾çš„è¿‡ç¨‹ï¼Œé çš„æ˜¯é™·é˜±è¡¨(trap table)ï¼Œé™·é˜±è¡¨ç”±æ“ä½œç³»ç»Ÿåœ¨å¼€æœºåˆå§‹åŒ–çš„æ—¶å€™å¯¹ç¡¬ä»¶è¿›è¡Œé…ç½®ï¼Œè€Œè·³è½¬çš„è¿‡ç¨‹æ˜¯é€šè¿‡CPUçš„ä¸€äº›ç‰¹æ®ŠæŒ‡ä»¤å®Œæˆçš„ã€‚

> **å—é™æ‰§è¡Œåè®®ï¼ˆLDEï¼‰**

![](https://i.loli.net/2019/09/21/MFwcDOXHepyGgfi.png)

> https://www.kernel.org/doc/html/latest/x86/kernel-stacks.html
>
> https://stackoverflow.com/questions/12911841/kernel-stack-and-user-space-stack
>
> > In a Linux system, every user process has 2 stacks, a user stack and a dedicated kernel stack for the process. The user stack resides in the user address space (first 3GB in 32-bit x86 arch.) and the kernel stack resides in the kernel address space (3GB-4GB in 32bit-x86) of the process.
> >
> > When a user process needs to execute some privileged instruction (a system call) it traps to kernel mode and the kernel executes it on behalf of the user process. **This execution takes place on the process' kernel stack.**
> >
> > The [**TSS (Task State Segment)**](https://en.wikipedia.org/wiki/Task_state_segment) is used to store the segment selector and stack pointer of the process' kernel stack.
> >
> > Upon a system call, the user process pushes all caller save registers in the process' user stack and executes [**int $0x80**](https://en.wikipedia.org/wiki/INT_(x86_instruction)) (0x80 is for system call**)** instruction. Then the **hardware** (not software) finds the process' kernel stack address from the TSS, loads those values to %**ss** (stack segment selector ) and pushes the old stack stack-pointer (**%esp**), old program-counter (**%eip**), old stack segment (**%ss**), code segment(**%cs**), and EFLAGS registers in the **process' kernel stack.** Hence, any operation requiring stack access uses this stack (not the user stack). After execution is over, the hardware pops the saved values from the kernel stack to their respective registers and resumes in the user stack.
> >
> > For a trap execution, the user stack can't be used because it might be corrupted by malicious user process. The kernel stack is used by kernel code only, so it is safe.
> >
> > For more info follow this link.

#### User stack & kernel stack

åœ°å€ä¸ä¸€æ ·ï¼Œæƒé™ä¸ä¸€æ ·ã€‚

- User stackåœ¨ç”¨æˆ·æ€
- Kernel stackåœ¨å†…æ ¸æ€
- æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªkernel stack
- syscallçš„æ—¶å€™ï¼Œé€šè¿‡ç¡¬ä»¶ï¼Œå¯„å­˜å™¨dataå°†è¿›è¡Œæš‚æ—¶çš„å­˜å‚¨å’Œæ¢å¤

#### ç­‰å¾…ç³»ç»Ÿè°ƒç”¨çš„åä½œæ–¹å¼

> å³OSç›¸ä¿¡ç¨‹åºä¼šå®šæœŸgive upã€‚
>
> - yield
> - I/O
> - å‘ç”Ÿé”™è¯¯ï¼Œé™·å…¥trap
> - å…¶ä»–ç³»ç»Ÿè°ƒç”¨

#### æ“ä½œç³»ç»Ÿå¹²é¢„çš„éåä½œæ–¹å¼

ä¾é æ—¶é’Ÿä¸­æ–­ï¼Œå³è¿è¡Œä¸€æ®µæ—¶é—´ï¼ˆä¸€èˆ¬æ˜¯å‡ æ¯«ç§’å°±ä¸­æ–­ä¸€æ¬¡ï¼‰ã€‚ä¸­æ–­çš„æ—¶å€™ï¼ŒOSå°±å¯ä»¥è·å¾—æ“æ§æƒäº†ã€‚ï¼ˆå½“ç„¶æ“ä½œç³»ç»Ÿä¹Ÿå¯ä»¥å…³ä¸­æ–­->ç‰¹æƒæ“ä½œï¼‰

#### ä¸Šä¸‹æ–‡åˆ‡æ¢

å†…æ ¸æ ˆpush&popã€‚

![](https://i.loli.net/2019/09/21/OZchYsWv8CnGKf3.png)

> æ³¨æ„ï¼Œå¯„å­˜å™¨è¢«ä¿å­˜å’Œæ¢å¤æœ‰2ç§æ–¹å¼ï¼š
>
> - ç¡¬ä»¶éšå¼ä¿å­˜ï¼ˆç›®æ ‡åœ°å€æ˜¯å†…æ ¸æ ˆï¼Œç”±ç¡¬ä»¶å®ç°ï¼‰ï¼›
> - æ“ä½œç³»ç»Ÿæ˜¾å¼ä¿å­˜ï¼ˆç›®æ ‡åœ°å€æ˜¯PCBçš„å†…å­˜ï¼Œlinux3.6å†…æ ¸ä»£ç `switch_to`ä¸­çš„æ³¨é‡Šè¡¨ç¤ºï¼‰ï¼›
>
> > Andï¼Œcontextæ˜¯ç”¨äºç”¨æˆ·è¿›ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œk-stackæ˜¯ç”¨ä¸å†…æ ¸æ€ä¸ç”¨æˆ·æ€çš„åˆ‡æ¢ã€‚

```c
/*
 * Context-switching clobbers all registers, so we clobber      \
 * them explicitly, via unused output variables.                \
 * (EAX and EBP is not listed because EBP is saved/restored     \
 * explicitly for wchan access and EAX is the return value of   \
 * __switch_to())           
 */
```

> > å†æ¬¡æ³¨æ„ï¼Œæ¯ä¸ªè¿›ç¨‹æœ‰2ç§ç±»å‹çš„stackï¼Œuser-modeå’Œkernel-modeï¼Œkernel-mode stackå°±æ˜¯æˆ‘ä»¬è¯´å†…æ ¸æ ˆã€‚
> >
> > Each user thread has both a **user-mode** stack and a **kernel-mode** stack. When a thread enters the kernel, the current value of the <u>user-mode stack</u> (`SS:ESP`) and <u>instruction pointer</u> (`CS:EIP`) are saved to the thread's <u>kernel-mode stack,</u> and the CPU switches to the kernel-mode stack - with the `int $80` syscall mechanism, this is done by the CPU itself. <u>The remaining register values and flags are then also saved to the kernel stack.</u>
> >
> > When a thread context-switches, it calls into the scheduler (the scheduler does not run as a separate thread - <u>it always runs in the context of the current thread</u>). The scheduler code selects a process to run next, and calls the `switch_to()` function. This function essentially just switches the kernel stacks - it saves <u>the current value of the stack pointer into the TCB</u> for the current thread (called `struct task_struct` in Linux), and loads a previously-saved stack pointer from the TCB for the next thread. At this point it also saves and restores some other thread state that isn't usually used by the kernel - things like floating point/SSE registers. <u>If the threads being switched don't share the same virtual memory space (ie. they're in different processes), the page tables are also switched.</u>
> >
> > So you can see that the core user-mode state of a thread isn't saved and restored at context-switch time - it's saved and restored to the thread's kernel stack <u>when you enter and leave the kernel.</u> The context-switch code doesn't have to worry about clobbering the user-mode register values - those are already safely saved away in the kernel stack by that point.

#### ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€

- 200-MHz Linux 1.3.37 ~ ç³»ç»Ÿè°ƒç”¨ 3Î¼s ä¸Šä¸‹æ–‡åˆ‡æ¢6Î¼s

> ç†è®ºåˆ†æï¼š
>
> - å¯„å­˜å™¨çš„ä¿å­˜ä¸æ¢å¤
> - Cacheåˆ·æ–°
> - æµæ°´çº¿ï¼Œåˆ†æ”¯é¢„æµ‹ç»“æœåˆ·æ–°
> - TLBï¼ˆçº¿ç¨‹çº§åˆ«å¯ä¸è€ƒè™‘ï¼‰

### è¿›ç¨‹è°ƒåº¦

åœ¨è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„æ—¶å€™ï¼Œå¦‚ä½•é€‰æ‹©å³å°†è¦åˆ‡æ¢åˆ°çš„è¿›ç¨‹ï¼Œæ¶‰åŠçš„å°±æ˜¯è¿›ç¨‹è°ƒåº¦çš„é—®é¢˜äº†ã€‚

> è°ƒåº¦é—®é¢˜2å¤§aimï¼šå…¬å¹³+æ€§èƒ½ï¼›

#### æŒ‡æ ‡

- å¸Œæœ›å°½æ—©å®Œæˆï¼ˆæ€§èƒ½ï¼‰ï¼šå‘¨è½¬æ—¶é—´=å®Œæˆæ—¶é—´-åˆ°è¾¾æ—¶é—´
- å¸Œæœ›å°½æ—©è¢«å“åº”ï¼ˆå…¬å¹³+æ€§èƒ½ï¼‰ï¼šå“åº”æ—¶é—´=é¦–æ¬¡è¿è¡Œæ—¶é—´-åˆ°è¾¾æ—¶é—´ï¼ˆé€‚ç”¨äºå¯¹æ—¶é—´æ•æ„Ÿçš„ç¨‹åºï¼‰

#### ç­–ç•¥

- FIFO
- SJFï¼ˆshortest job firstï¼‰ï¼šæœ€ä¼˜ï¼Œå¹³å‡å‘¨è½¬æ—¶é—´æœ€çŸ­ï¼ˆåŒæ—¶åˆ°è¾¾è¿›ç¨‹ç”±å¼€å§‹åˆ°è¢«è°ƒåº¦å®Œçš„æ—¶é—´æ€»åˆ/è¢«è°ƒåº¦è¿›ç¨‹æ•°é‡ï¼‰ï¼ˆ$T=Nt_1+(N-1)t_2+\cdots+t_N$ï¼‰

> ç¼ºç‚¹ï¼šéæŠ¢å å¼ï¼Œè‹¥æœ‰æ–°çš„çŸ­æ—¶é—´è¿›ç¨‹æ¥äº†ï¼Œè¿˜æ˜¯ä¼šè®©è€è¿›ç¨‹å…ˆæ‰§è¡Œã€‚

- STCFï¼ˆæœ€çŸ­å®Œæˆæ—¶é—´ä¼˜å…ˆShortest Time-to-Completion Firstï¼‰ï¼šæŠ¢å å¼ã€‚åŒæ ·æ˜¯æœ€ä¼˜çš„ã€‚
- RR(Round-Robin è½®è½¬)ï¼šè§£å†³çš„æ˜¯å“åº”æ—¶é—´çš„é—®é¢˜ã€‚ï¼ˆå¯¹å‘¨è½¬æ—¶é—´ä¸å‹å¥½ï¼Œä½†ç¬¦åˆå…¬å¹³æ€§ï¼‰
- Overlap I/O

#### é—®é¢˜

ä¸Šé¢å¾ˆå¤šç­–ç•¥æ˜¯å‡è®¾æˆ‘ä»¬çŸ¥é“æ•´ä¸ªè¿è½¬æ—¶é—´çš„é•¿åº¦ï¼Œä½†å®é™…ä¸Šæˆ‘ä»¬å¹¶æ— æ³•çŸ¥é“â€¦æ‰€ä»¥æˆ‘ä»¬åº”è¯¥åˆ©ç”¨æœ€è¿‘çš„ç­–ç•¥å»é¢„æµ‹æœªæ¥â€¦ï¼ˆå¤šçº§åé¦ˆé˜Ÿåˆ—ï¼‰

### MLFQ å¤šçº§åé¦ˆé˜Ÿåˆ—

#### è®¾è®¡åˆè¡·

- naiveä½¿ç”¨åˆ†æ—¶ç­–ç•¥ä¼šå¯¼è‡´**å‘¨è½¬æ—¶é—´**ä¸ä½³
- ä½¿ç”¨å…¶ä»–çš„ç­–ç•¥**å“åº”æ—¶é—´**

> å—¯ï¼Œå°±æ˜¯æ‹¿æ¥æƒè¡¡å‘¨è½¬æ—¶é—´å’Œå“åº”æ—¶é—´çš„ã€‚

#### è§„åˆ™

1. ğŸŒŸ æŒ‰ä¼˜å…ˆçº§æ‰§è¡Œ
2. ğŸŒŸ åŒä¼˜å…ˆçº§åˆ™è½®è½¬
3. ğŸŒŸ æ–°ä»»åŠ¡ä»æœ€é«˜ä¼˜å…ˆçº§å¼€å§‹
4. ğŸŒŸ ä½¿ç”¨å®Œä¸€ä¸ªæ—¶é—´ç‰‡åˆ™é™ä½ä¸€æ¬¡ä¼˜å…ˆçº§
5. ğŸŒŸ å› ä¸ºå…¶ä»–åŸå› ï¼ˆæ¯”å¦‚IOï¼‰è€Œé‡Šæ”¾CPUåˆ™ä¸æ”¹å˜ä¼˜å…ˆçº§ï¼ˆå¯¹äºäº¤äº’å‹çš„è¿›ç¨‹ï¼Œç”±äºæˆ‘ä»¬å¸Œæœ›å®ƒè¢«å³ä½¿å“åº”ï¼Œæ‰€ä»¥æˆ‘ä»¬å¸Œæœ›å®ƒä¼˜å…ˆçº§é«˜ï¼‰

> åªè¦è°ƒåº¦ä¸æ˜¯ç‰¹åˆ«é¢‘ç¹ï¼Œé‚£ä¹ˆç›¸å¯¹æ¥è¯´è°ƒåº¦çš„å¼€é”€å°±å¯ä»¥å¿½ç•¥ä¸è®¡ã€‚

#### é—®é¢˜

- æ¶æ„ç¨‹åºå¯ä»¥é€šè¿‡é¢‘ç¹IOæ¥æŠ¢å ä¼˜å…ˆçº§ï¼ˆæ„šå¼„é—®é¢˜ï¼‰
- å¦‚æœâ€œéäº¤äº’â€å‹è¿›ç¨‹çªç„¶å˜æˆâ€œäº¤äº’å‹â€è¿›ç¨‹ï¼Œé‚£ä¹ˆå“åº”çš„é—®é¢˜è¿˜æ˜¯æ²¡æœ‰è¢«è§£å†³

#### æ”¹è¿›ï¼šæå‡ä¼˜å…ˆçº§

- æ€è·¯ä¸€ï¼šå‘¨æœŸæ€§æå‡æ‰€æœ‰å·¥ä½œçš„ä¼˜å…ˆçº§ï¼ˆé’ˆå¯¹é—®é¢˜2ï¼‰
- ğŸŒŸ ç»è¿‡ä¸€æ®µæ—¶é—´ï¼ˆJohn Ousterhoutç§°ä¹‹ä¸ºâ€œå·«æ¯’å¸¸é‡(voo-doo constant)â€ï¼‰ï¼Œç³»ç»Ÿå°†æ‰€æœ‰å·¥ä½œé‡æ–°åŠ å…¥æœ€é«˜ä¼˜å…ˆé˜Ÿåˆ—ã€‚
- æ€è·¯äºŒï¼šæ›´å¥½çš„è®¡æ—¶æ–¹å¼ï¼ˆè§£å†³æ„šå¼„é—®é¢˜ï¼‰

> è¦è§£å†³æ„šå¼„é—®é¢˜ï¼Œæˆ‘ä»¬é¦–å…ˆå¾—è§£é™¤â€œå‘ç”ŸIOä¸é™ä½ç­‰çº§â€çš„é­”å’’ï¼Œç„¶åå†ä¿è¯å…¬å¹³ï¼Œé‚£ä¹ˆä¹…é‡æ–°è§„å®šè®¡æ—¶æ–¹å¼ã€‚

- ä¹‹å‰çš„è®¡æ—¶ï¼šã€è°ƒåº¦æ—¶é‡æ–°è®¡æ—¶ã€‘ç»™å®šæ—¶é—´ç‰‡ï¼Œæ—¶é—´ç‰‡ç»“æŸæˆ–å‘ç”Ÿä¸­æ–­é‡æ–°è®¡æ—¶ã€‚+ä¸­æ–­ä¸é™çº§
- æ–°çš„è®¡æ—¶ï¼šã€æ¯ä¸ªä»»åŠ¡å¯¹åº”ä¸€ä¸ªæ—¶é—´ã€‘ç»´æŠ¤æ—¶é—´ï¼Œåªæœ‰å½“ä¸€ä¸ªè¿›ç¨‹å½»å½»åº•åº•çš„ç”¨å®Œä¸€ä¸ªæ—¶é—´ç‰‡æ‰é™çº§ã€‚
- ğŸŒŸ ä¸€æ—¦ä¸€ä¸ªå·¥ä½œå®Œæˆäº†å…¶åœ¨**<u>æŸä¸€å±‚</u>**ä¸­çš„**æ—¶é—´é…é¢**ï¼Œé‚£ä¹ˆå°±é™ä½ä¼˜å…ˆçº§ã€‚ï¼ˆé’ˆå¯¹é—®é¢˜ä¸€ï¼‰

> ä¹‹å‰çš„æ—¶é—´ç‰‡æ˜¯åŒ…æ‹¬IOç­‰å…¶ä»–æ“ä½œçš„ï¼Œè€Œæ–°çš„æ—¶é—´é…é¢æ˜¯æŸä¸€çº§æŒ‡ç”¨äºâ€œrunningâ€çš„æ—¶é—´ã€‚

#### é…ç½®

- æå‡ä¼˜å…ˆçº§çš„æ—¶é—´å‘¨æœŸçš„è®¾ç½®
- ä¼˜å…ˆé˜Ÿåˆ—çš„å±‚æ•°
- ï¼ˆæ¯ä¸€å±‚ï¼‰æ—¶é—´ç‰‡å¤§å°

> ä¸€èˆ¬æ¥è¯´MLFQè¶Šé«˜ä¼˜å…ˆçº§ï¼Œæ—¶é—´ç‰‡è¶ŠçŸ­ï¼ˆå“åº”å¿«ï¼‰ï¼Œè¶Šä½åˆ™æ—¶é—´ç‰‡è¶Šé•¿ã€‚

#### Ousterhoutå®šå¾‹

å°½é‡é¿å…å·«æ¯’å¸¸é‡ï¼ˆvoo-doo constantï¼‰ã€‚

#### å®ç°

- Solaris: è¡¨ï¼ˆé…ç½®ï¼‰ï¼Œé»˜è®¤60å±‚â€¦ï¼Œ20ms~å‡ ç™¾msï¼Œæ¯ä¸€ç§’åˆ·æ–°ä¸€æ¬¡ä¼˜å…ˆçº§ã€‚
- å…¶ä»–ï¼šæ•°å­¦å…¬å¼è°ƒæ•´ä¼˜å…ˆçº§ã€‚â€”â€”FreeBSDï¼ŒåŸºäºå½“å‰è¿›ç¨‹ä½¿ç”¨äº†å¤šå°‘CPUï¼Œç„¶åæœ‰ä¸ªè®¡ç®—ä¼˜å…ˆçº§çš„å…¬å¼ã€‚

#### ç³»ç»Ÿè®¾è®¡çš„big idea

- ä½¿ç”¨hintï¼Œé€šè¿‡å¯¹hintçš„å¤„ç†ï¼Œæ¥é€‰æ‹©æ›´ä¼˜çš„ç­–ç•¥ï¼›

#### æ€»ç»“

- åˆå§‹éƒ½åœ¨æœ€é«˜ä¼˜å…ˆçº§
- åŒä¼˜å…ˆçº§ä½¿ç”¨æ—¶é—´ç‰‡è½®è½¬
- æ—¶é—´é…é¢â€”â€”è®°å½•**<u>æŸä¸€çº§</u>**ä¼˜å…ˆé˜Ÿåˆ—çš„**<u>çœŸæ­£çš„CPU run time</u>**
- é€šè¿‡ä¸€æ®µæ—¶é—´å°±åˆ·æ–°å·¥ä½œé˜Ÿåˆ—

> æ²¡é”™ä»–æ˜¯åé¦ˆï¼ˆè‡ªé€‚åº”ï¼‰çš„ï¼ï¼ï¼

### åŸºäºå½©ç¥¨æœºåˆ¶çš„è°ƒåº¦

> è¿™ç§æœºåˆ¶å¯ä»¥ç”¨äºâ€œèµ„æºåˆ†é…â€çš„å„ä¸ªé—®é¢˜ä¸Šã€‚
>
> ä¸»é¢˜ï¼š**<u>ä¸€åˆ‡ä¸ºäº†å…¬å¹³ã€‚</u>**

#### ç›®çš„

æ¢ä¸€ä¸ªç›®æ ‡å‡½æ•°ï¼š**<u>è®¤ä¸ºè°ƒåº¦ç¨‹åºçš„æœ€ç»ˆç›®æ ‡ï¼Œæ˜¯ç¡®ä¿æ¯ä¸ªå·¥ä½œè·å¾—ä¸€å®šæ¯”ä¾‹çš„CPUæ—¶é—´ã€‚</u>**

#### How

æ¯ä¸ªè¿›ç¨‹åˆ†é…ä¸€å®šé‡çš„å½©ç¥¨ï¼ŒæŒ‰æŸä¸€è¿›ç¨‹å½©ç¥¨å æ‰€æœ‰è¿›ç¨‹å½©ç¥¨çš„æ¯”ä¾‹ä½œä¸º **è¢«è°ƒåº¦çš„æ¦‚ç‡**ã€‚

éœ€è¦çš„ä¸œè¥¿ï¼š

> - éšæœºæ•°ç”Ÿæˆå™¨
> - è¿›ç¨‹åˆ—è¡¨

> **å½©ç¥¨æŠ½å¥–ç³»ç»Ÿçš„é«˜æ•ˆå®ç°**ï¼šå¯¹äºé€šè¿‡

#### éšæœºæ€§æ˜¯ä¸ªå¥½ä¸œè¥¿

æ—¢ç„¶èŠåˆ°æ¦‚ç‡ï¼Œé‚£ä¹ˆå°±æœ‰éšæœºæ•°ã€‚éšæœºæ•°æ˜¯ä¸ªå¥½ä¸œè¥¿ï¼Œèƒ½å¤Ÿå¸®åŠ©ç³»ç»Ÿä»éš¾ä»¥é‡åˆ°çš„â€œéº»çƒ¦çš„è¾¹è§’æƒ…å†µâ€ä¸­è§£æ•‘å‡ºæ¥ã€‚

#### æ›´å¤šç‰¹æ€§

- å½©ç¥¨è½¬è®©ï¼ˆåœ¨server-clientæ¨¡å‹ä¸­å¯ä»¥é€šè¿‡è½¬è®©æå‡ä¸¤ç«¯æ€§èƒ½ï¼‰
- å½©ç¥¨é€šèƒ€ï¼ˆä¸€ä¸ªè¿›ç¨‹å¯ä»¥ä¸´æ—¶å¢åŠ æˆ–å‡å°‘è‡ªå·±çš„å½©ç¥¨æ•°é‡ï¼‰

#### Metric

> å¯¹äºä¸¤ä¸ªåŒç­‰çº§çš„ä»»åŠ¡ï¼šå…¶å®Œæˆ**æ—¶åˆ»**ä¹‹æ¯”ä¸ºæˆ‘ä»¬è¯´çš„ä¸å…¬å¹³æŒ‡æ ‡ã€‚ï¼ˆè¶Šé è¿‘1è¶Šå…¬å¹³ï¼‰

$$
U=\frac{T_1}{T_2}
$$

### æ­¥é•¿è°ƒåº¦ï¼šæ›´åŠ å…¬å¹³

è®°å½•æ¯ä¸ªè¿›ç¨‹çš„è¡Œç¨‹ï¼Œæ¯ä¸ªè¿›ç¨‹æ‰§è¡Œä¸€æ¬¡ï¼š`è¡Œç¨‹ += æ­¥é•¿`ã€‚

- è¿›ç¨‹æ­¥é•¿ä¸å½©ç¥¨æ•°æˆåæ¯”ï¼›
- æ¯æ¬¡è°ƒåº¦æ—¶ï¼Œé€‰æ‹©**<u>è¡Œç¨‹çŸ­</u>**çš„è¿›ç¨‹ï¼Œå°†å…¶åŠ å…¥è°ƒåº¦é˜Ÿåˆ—çš„é˜Ÿé¦–ï¼›

### è¿›ç¨‹è°ƒåº¦æ€»ç»“

- å½©ç¥¨è°ƒåº¦ï¼šä¸éœ€è¦ä¿®æ”¹å…¨å±€çŠ¶æ€ï¼Œåªéœ€è¦åœ¨åŠ å…¥è¿›ç¨‹çš„æ—¶å€™ç»™å½©ç¥¨å°±å¥½ï¼Œç„¶åå°±èƒ½åšå†³å®šäº†ï¼›
- MLFQï¼šç¬¦åˆä½å‘¨è½¬æ—¶é—´ï¼Œä½å“åº”æ—¶é—´çš„è¦æ±‚ï¼›
- æ­¥é•¿è°ƒåº¦ï¼šå…¬å¹³ï¼›

> å½©ç¥¨è°ƒåº¦å’Œæ­¥é•¿è°ƒåº¦éƒ½æ˜¯è¯•å›¾ä¿è¯æ¯”ä¾‹ç¬¦åˆé¢„æœŸã€‚

### åœ°å€ç©ºé—´

#### ä¸Šå¤æ—¶ä»£

- æ“ä½œç³»ç»Ÿæ˜¯ä¸ªåº“ï¼Œä¸€å°PCä¸€ä¸ªç¨‹åºï¼Œç›´æ¥ç”¨ç‰©ç†åœ°å€ï¼›

#### å› ä¸ºæ˜‚è´µæ‰€ä»¥å…±äº«

- å¤šé“ç¨‹åº
- æ—¶åˆ†å…±äº«ï¼ˆæé«˜äº¤äº’æ€§ï¼‰

> é‚£ä¹ˆå†…å­˜å‘¢ï¼Ÿ
>
> å½“æ—¶æ˜¯ç›´æ¥è®©ä¸€ä¸ªè¿›ç¨‹ç‹¬å ä¸€æ®µæ—¶é—´çš„å†…å­˜ï¼Œå…¶ä»–çš„ä¸œè¥¿å…ˆä¿å­˜åˆ°ç£ç›˜ã€‚é—®é¢˜å°±æ˜¯æ•ˆç‡å¤ªä½äº†ï¼ˆä½¿ç”¨çš„å†…å­˜è¶Šå¤šï¼Œåˆ‡æ¢æ•ˆç‡è¶Šä½ï¼‰ã€‚
>
> æ‰“ç ´è¿™ç‚¹éœ€è¦è®© ***å¤šä¸ªè¿›ç¨‹åŒæ—¶ä½¿ç”¨å†…å­˜***ã€‚æ–°çš„é—®é¢˜ä¹Ÿæ¥äº†ï¼Œå¦‚ä½•ä¿æŠ¤å„ä¸ªè¿›ç¨‹ã€‚

#### åœ°å€ç©ºé—´

å¯¹ç‰©ç†å†…å­˜çš„åœ°å€åšä¸€å±‚æŠ½è±¡ï¼Œå¾—åˆ°è™šæ‹ŸåŒ–åçš„åœ°å€ç©ºé—´ã€‚

- é™æ€æ•°æ®
- ä»£ç 
- æ ˆ
- å †

#### ç©ºé—´è™šæ‹ŸåŒ–çš„ç›®æ ‡

- ç§æœ‰
- å°½å¯èƒ½å¤§

> å…¶å®ç°ä¹Ÿæ˜¯éœ€è¦ä¾æ‰˜ç¡¬ä»¶ï¼›

#### éš”ç¦»

éš”ç¦»æ˜¯å¯é systemçš„ä¸€ä¸ªå…³é”®åŸåˆ™ã€‚ç›®çš„æ˜¯å‡å°‘ä¸ªä½“ä¹‹å‰çš„å½±å“ï¼ˆè¿›ç¨‹Aç‚¸äº†ï¼Œä¸ä¼šå½±å“è¿›ç¨‹Bï¼‰ã€‚

#### ç©ºé—´è™šæ‹ŸåŒ–çš„å…¶ä»–ç›®æ ‡

- é€æ˜æ€§

å› ä¸ºæ˜¯é€æ˜çš„ï¼Œæ‰€ä»¥è¿›ç¨‹è¦åšåˆ°â€œç›¸ä¿¡ç›¸ä¿¡æ“ä½œç³»ç»Ÿçš„éª—å±€â€ã€‚ï¼ˆå†™ä¸€æ®µæ‰“å°åœ°å€çš„ç¨‹åºæ‰“å°çš„æ˜¯è™šæ‹Ÿåœ°å€ï¼‰

- é«˜æ€§èƒ½ï¼ˆæ—¶é—´å’Œç©ºé—´ï¼‰
- ä¿æŠ¤éš”ç¦»

#### GLIBC 

ä¸ºå­—ç¬¦ä¸²åˆ†é…å†…å­˜çš„æ—¶å€™åº”è¯¥å¤šåˆ†é…ä¸€ä¸ª`byte`ã€‚

## Concurrency

### Intro

#### çº¿ç¨‹å’Œè¿›ç¨‹çš„åŒºåˆ«

çº¿ç¨‹ä¹‹é—´å…±äº«åœ°å€ç©ºé—´ï¼ˆåœ°å€ç©ºé—´ä¿æŒä¸å˜ï¼Œå³ä¸ç”¨åˆ‡æ¢é¡µè¡¨ï¼‰ï¼Œå¯ä»¥è®¿é—®ç›¸åŒçš„æ•°æ®ï¼ˆå½“ç„¶ä¹Ÿæœ‰`thread_local`çš„æ•°æ®ï¼‰ã€‚

> è¿›ç¨‹ï¼šPCBï¼ˆæ“ä½œç³»ç»Ÿå†…æ ¸çš„ä¸€ç§æ•°æ®ç»“æ„ï¼‰
>
> çº¿ç¨‹ï¼šTCBï¼ˆ1KBçš„æ ·å­ï¼‰

#### ä¸´ç•ŒåŒº

è®¿é—®å…±äº«èµ„æºçš„ä¸€æ®µ**ä»£ç **ã€‚

#### ç«æ€æ¡ä»¶

å­˜åœ¨å¤šä¸ªçº¿ç¨‹å¤§æ¦‚åŒæ—¶è¿›å…¥ä¸´ç•ŒåŒºï¼Œä¸”å­˜åœ¨è¯•å›¾**æ›´æ–°å…±äº«æ•°æ®çš„æƒ…å†µ**ã€‚

#### åŸå­æ“ä½œ

ä¸€ç³»åˆ—æ“ä½œè¦ä¹ˆå·²ç»å‘ç”Ÿäº†ï¼Œè¦ä¹ˆæ²¡æœ‰å‘ç”Ÿï¼Œæ— æ³•è§‚å¯Ÿå…¶ä¸­é—´æ€ã€‚

### é”

ä½¿æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ä¸´ç•ŒåŒºã€‚

#### è¯„ä»·é”

- æ€§èƒ½
- å…¬å¹³æ€§ï¼ˆæ˜¯å¦èƒ½é›¨éœ²å‡æ²¾ï¼‰

#### å®ç°ï¼ˆåŒ…æ‹¬åŒæ­¥åŸè¯­ï¼‰

> åŒæ­¥åŸè¯­ä¿è¯è¯¥æ“ä½œæ˜¯åŸå­çš„ã€‚

- å•æ ¸â€”â€”ç¦æ­¢ä¸­æ–­
- è‡ªæ—‹é”ï¼ˆæŠ¢ä¸åˆ°é”å°±è‡ªæ—‹ï¼‰
  - TASï¼ˆåªèƒ½ç”¨æ¥æŠ¢é”ï¼‰
  - CASï¼ˆæœ‰é¢å¤–çš„expectedå€¼ï¼Œå¯å¯¹åº”æ›´å¤šçš„æƒ…å†µï¼‰
  - é“¾æ¥åŠ è½½å’Œæ¡ä»¶å­˜å‚¨ï¼ˆå°±æ˜¯æ£€æŸ¥è‡ªä»ä¸Šä¸€æ¬¡æ›´æ–°é“¾æ¥åœ°å€èµ·ï¼Œé“¾æ¥åœ°å€æ˜¯å¦è¢«æ›´æ”¹ï¼Œè‹¥æ²¡æœ‰è¢«æ›´æ”¹åˆ™è¯´æ˜æ²¡äººæŠ¢é”ï¼Œé‚£ä¹ˆé”å°±å½’è‡ªå·±äº†ï¼ŒæŠ¢åˆ°åæŠŠé“¾æ¥åœ°å€çš„å€¼è®¾ç½®ä¸ºå ç”¨å³å¯ï¼‰
  - FAAï¼ˆè‡ªå¢ï¼Œä½¿ç”¨ticket-turnçš„æ–¹æ³•ä¿è¯é›¨éœ²å‡æ²¾ï¼‰

#### è§£å†³è‡ªæ—‹è¿‡å¤šçš„é—®é¢˜

- yieldï¼ˆç«‹å³åœæ­¢å¯¹å½“å‰çº¿ç¨‹çš„è°ƒåº¦ï¼‰
- ç¡è§‰å¹¶ä¸¢åˆ°é˜Ÿåˆ—é‡Œï¼ˆè¿™æ ·ä¹Ÿä¿è¯äº†å…¬å¹³æ€§ï¼Œä¸è¿‡è¿˜æ˜¯éœ€è¦é”æ¥å¸®å¿™ï¼Œå³é”ä½é˜Ÿåˆ—ï¼‰
  - Solaris:
    - Park & Unpark & Setparkï¼ˆé˜²æ­¢å¹¶å‘æ‰§è¡ŒPark-Unparkæ“ä½œæ—¶ï¼ŒUnparkå…ˆï¼Œæœ€åParkäº†ï¼‰
  - Linux:
    - Futex
    - äºŒé˜¶æ®µé”ï¼š
      - å¿«é€Ÿè‡ªæ—‹æœ‰é™æ¬¡ï¼ˆä¸€èˆ¬ä¸€æ¬¡å°±å¥½
      - ç„¶åå†ä¸ŠFutex

#### è¯»å†™é”

- è®°å½•è¯»è€…æ•°é‡ï¼›
- ä¸€ä¸ªåŒæ­¥åŸè¯­ï¼›

```c++
// è¯»å†™é”çš„è®¡æ•°å™¨
#include <shared_mutex>

class counter
{
public:
    std::size_t get() const {
        std::shared_lock l(sm_);
        return cnt_;
    }
    void inc(){
        std::unique_lock l(sm_);
        ++cnt_;
    }
    void reset(){
        std::unique_lock l(sm_);
        cnt_ = 0;
    }
private:
    mutable std::shared_mutex sm_;
    std::size_t               cnt_;
};
```

è¯»å†™é”çš„å®ç°

```c++
class rwlock
{// å¦‚æœreadlockå¯¹åº”çš„ä¸´ç•ŒåŒºäº‹æƒ…ä¸æ˜¯å¾ˆå¤šçš„è¯ï¼Œå°±æ²¡å¿…è¦rwlockäº†ã€‚
public:
    void read_lock()
    {
// atomic cannot help. Cuz when wm_.lock is going to be happened. Interrupt may occur.
        std::lock_guard l(rm_);
        if(++rcnt_ == 1)
            wm_.lock();
    }
    void read_unlock()
    {
        std::lock_guard l(rm_);
        if(--rcnt_ == 0)
            wm_.unlock();
    }
    void write_lock()
    {
        wm_.lock();
    }
    void write_unlock()
    {
        wm_.unlock();
    }
private:
    mutable std::mutex  wm_;
    mutable std::mutex  rm_;
    mutable std::size_t rcnt_;
};
```

### Concurrent Data Structure

#### åŸå­è®¡æ•°ä¼˜åŒ–

æŸå¤±å‡†ç¡®æ€§è¿›è¡Œä¼˜åŒ–

> æ¯ä¸ªçº¿ç¨‹å»ºç«‹ä¸€ä¸ªlocalçš„è®¡æ•°ï¼Œå½“localçš„æ“ä½œç´¯ç§¯åˆ°ä¸€å®šå€¼çš„æ—¶å€™å†å¯¹åŸå­è®¡æ•°è¿›è¡Œæ›´æ–°ï¼›

#### å¼•ç”¨åŸå­è®¡æ•°ä¼˜åŒ–

å½“localçš„åŸå­è®¡æ•°ä¸º0çš„æ—¶å€™å†æ›´æ–°åŸå­è®¡æ•°ã€‚ï¼ˆæ²¡æœ‰å‡†ç¡®æ€§çš„æŸè€—ï¼‰

#### å¤§é”

> æ¯”å¦‚LINUXçš„å†…æ ¸é”BKLï¼›

#### ç»†ç²’åº¦é”

- è¿‡æ‰‹é”ï¼ˆé¢‘ç¹é‡Šæ”¾å’Œè·å–é”ï¼Œæ¶ˆè€—è¾ƒå¤§ï¼‰
- å¹¶å‘å“ˆå¸Œè¡¨ï¼šæ¯ä¸ªæ¡¶ä¸€ä¸ªé”

### Condition Variable

#### waitä¸€å®šè¦åŠ é”

notifyå¦‚æœåªè€ƒè™‘è‡ªèº«çš„çº¿ç¨‹å®‰å…¨çš„è¯ï¼Œåæ­£C++æ ‡å‡†æ˜¯ä¿è¯çš„ï¼Œå¯ä»¥ç›´æ¥æŠŠnotifyæ”¾ä¸´ç•ŒåŒºå¤–ã€‚Linuxçš„pthreadæ®ææ¶¦ä¸­è¯´ä¹Ÿæ˜¯ä¿è¯çº¿ç¨‹å®‰å…¨çš„ã€‚

#### Linuxçš„ç®¡é“æ˜¯producer/consumeræ¨¡å‹

```shell
grep foo f.txt | wc -l
# ä¸¤ä¸ªè¿›ç¨‹å¹¶å‘æ‰§è¡Œï¼Œå‰è€…æ˜¯producerï¼Œæ ‡å‡†è¾“å‡ºé‡å®šå‘åˆ°ç®¡é“ï¼Œç”±åè€…consumerä½¿ç”¨
```

#### è¦†ç›–æ¡ä»¶

ä»¥å¹¶å‘åŠ¨æ€å†…å­˜åˆ†é…ä¸ºä¾‹ï¼Œå½“å†…å­˜ä¸å¤Ÿçš„æ—¶å€™å°±`wait_until(æœ‰å†…å­˜)`ï¼Œè€Œå½“çœŸæ­£æœ‰å†…å­˜çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¡ä»¶å˜é‡ä¸çŸ¥é“åº”è¯¥`notify which thread`ã€‚ç®€å•çš„åšæ³•å°±æ˜¯`notify_all`ï¼ˆä½†æ€§èƒ½ä¸ä¼šå¾ˆå¥½ï¼‰ï¼›

## å…¶ä»–

#### 9.24 å‡Œæ™¨å’Œææ¶¦ä¸­è®¨è®ºæ¡ä»¶å˜é‡çš„ç»“æœ

- å…ˆnotifyå†waitï¼Œwaitèƒ½ä¸èƒ½æ¥å—åˆ°è¿™ä¸ªnotify â€”â€” ä¸èƒ½

> å› ä¸ºåœ¨pthread_cond_tå’ŒC++ä¸­condition_variableçš„å®ç°ä¸­ï¼Œé¦–å…ˆwaitéœ€è¦æ‹¿åˆ°ä¸€æŠŠé”ï¼Œç„¶åçœ‹çœ‹æ¡ä»¶æ˜¯å¦è¾¾æˆï¼Œè¾¾ä¸æˆå°±unlockï¼Œå¹¶è¿›å…¥ä¼‘çœ é˜Ÿåˆ—ã€‚notifyçš„è¯å°±æ˜¯å”¤é†’æŸä¸€çº¿ç¨‹æŠ¢ä¸€ä¸‹é”ç„¶åæŸ¥çœ‹ä¸€ä¸‹ç»“æœï¼Œå¦‚æœOKï¼Œå°±ç»§ç»­ï¼Œä¸è¡Œå°±unlockã€‚
>
> **ç»“è®º**ï¼š
>
> - notify after unlock
> - waitæ“ä½œå°†ä¸´ç•ŒåŒºåˆ†æˆ2æ®µ

- notifyæ“ä½œçš„çº¿ç¨‹å®‰å…¨æ€§ï¼š

> åœ¨C++ä¸­ï¼š
>
> `notify_one()`/`notify_all()` çš„æ•ˆæœä¸ `wait()`/`wait_for()`/`wait_until()` çš„ä¸‰ä¸ªåŸå­éƒ¨åˆ†çš„æ¯ä¸€è€…ï¼ˆè§£é”+ç­‰å¾…ã€å”¤é†’å’Œé”å®šï¼‰ä»¥èƒ½çœ‹åšåŸå­å˜é‡[ä¿®æ”¹é¡ºåº](https://zh.cppreference.com/w/cpp/atomic/memory_order#.E4.BF.AE.E6.94.B9.E9.A1.BA.E5.BA.8F)å•ç‹¬å…¨åºå‘ç”Ÿï¼šé¡ºåºå¯¹æ­¤å•ç‹¬çš„ condition_variable æ˜¯ç‰¹å®šçš„ã€‚è­¬å¦‚ï¼Œè¿™ä½¿å¾— `notify_one()` ä¸å¯èƒ½è¢«å»¶è¿Ÿå¹¶è§£é”æ­£å¥½åœ¨è¿›è¡Œ `notify_one()` è°ƒç”¨åå¼€å§‹ç­‰å¾…çš„çº¿ç¨‹ã€‚
>
> é€šçŸ¥çº¿ç¨‹ä¸å¿…ä¿æœ‰ç­‰å¾…çº¿ç¨‹æ‰€ä¿æœ‰çš„åŒä¸€äº’æ–¥ä¸Šçš„é”ï¼›å®é™…ä¸Šè¿™ä¹ˆåšæ˜¯åŠ£åŒ–ï¼Œå› ä¸ºè¢«é€šçŸ¥çº¿ç¨‹å°†ç«‹å³å†æ¬¡é˜»å¡ï¼Œç­‰å¾…é€šçŸ¥çº¿ç¨‹é‡Šæ”¾é”ã€‚ç„¶è€Œä¸€äº›å®ç°ï¼ˆå°¤å…¶æ˜¯è®¸å¤š pthread çš„å®ç°ï¼‰è¾¨è¯†æ­¤æƒ…å½¢ï¼Œåœ¨é€šçŸ¥è°ƒç”¨ä¸­ï¼Œç›´æ¥ä»æ¡ä»¶å˜é‡é˜Ÿåˆ—è½¬ç§»ç­‰å¾…çº¿ç¨‹åˆ°äº’æ–¥é˜Ÿåˆ—ï¼Œè€Œä¸å”¤é†’å®ƒï¼Œä»¥é¿å…æ­¤â€œæ€¥ä¿ƒå¹¶ç­‰å¾…â€åœºæ™¯ã€‚
>
> ç„¶è€Œï¼Œåœ¨è¦æ±‚ç²¾ç¡®è°ƒåº¦äº‹ä»¶æ—¶ï¼Œå¯èƒ½å¿…é¡»åœ¨å¤„äºé”ä¸‹æ—¶é€šçŸ¥ï¼Œä¾‹å¦‚ï¼Œåœ¨è‹¥æ»¡è¶³æ¡ä»¶åˆ™çº¿ç¨‹å°†é€€å‡ºç¨‹åºï¼Œå¯¼è‡´ææ„é€šçŸ¥çº¿ç¨‹çš„ condition_variable çš„æƒ…å†µä¸‹ã€‚äº’æ–¥è§£é”ä¹‹åï¼Œä½†åœ¨é€šçŸ¥å‰çš„è™šå‡å”¤é†’å¯èƒ½å¯¼è‡´é€šçŸ¥åœ¨è¢«é”€æ¯å¯¹è±¡ä¸Šè°ƒç”¨ã€‚

